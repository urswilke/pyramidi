---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# pyramidi <a href='https://github.com/urswilke/pyramidi/'><img src='man/figures/hex-pyramidi_compact.png' align="right" height="139" /></a>

<!-- badges: start -->
[![Travis build status](https://travis-ci.org/urswilke/pyramidi.svg?branch=master)](https://travis-ci.org/github/urswilke/pyramidi)
[![Codecov test coverage](https://codecov.io/gh/urswilke/pyramidi/branch/master/graph/badge.svg)](https://codecov.io/gh/urswilke/pyramidi?branch=master)
[![R-CMD-check](https://github.com/urswilke/pyramidi/workflows/R-CMD-check/badge.svg)](https://github.com/urswilke/pyramidi/actions)
<!-- badges: end -->

**Work in progress!**

♪ ♫ ♩ ♬ ♪ ♫ ♩ ♬ ♪ ♫ ♩ ♬ ♪ ♫ ♩ ♬ ♪ ♫ ♩ ♬ ♪ ♫ ♩ ♬ ♪ ♫ ♩ ♬ ♪ ♫ ♩ ♬ ♪ ♫ ♩ ♬ 

The goal of pyramidi is to read in dataframes generated by the python package
[miditapyr](https://pypi.org/project/miditapyr/). These dataframes contain midi data. Then the midi information (one
line per event) can be translated into a wide format (one line per note). This 
facilitates plotting piano roll plots. These dataframes can then be written back
to midi files (again using miditapyr).

## Installation

You can install pyramidi from [github](https://github.com/urswilke/pyramidi) with:

``` r
## install remotes package if it's not already
if (!requireNamespace("remotes", quietly = TRUE)) {
  install.packages("remotes")
}

## install dev version of rtweettree from github
remotes::install_github("UrsWilke/pyramidi")
```

The python package [miditapyr](https://pypi.org/project/miditapyr/) also needs to be installed via 

```sh
pip install miditapyr
```

in your virtual environment.

## Basic usage

### Load libraries
```{r, reticulate_local, echo=FALSE}
reticulate::use_python("/home/chief/anaconda3/bin/python")

```

```{r load_libs, message=FALSE}
library(pyramidi)
library(tidyverse)
library(zeallot)
```

### Extract midi file information into dataframe

```{r midi_df, message=FALSE}
midi_file_str <- system.file("extdata", "test_midi_file.mid", package = "pyramidi")

midifile <- mido$MidiFile(midi_file_str)
ticks_per_beat <- midifile$ticks_per_beat

dfc = miditapyr$midi_to_df(midifile)
head(dfc, 20)
```


```{r ticksperbeat}
ticks_per_beat
```


```{r}
df <- miditapyr$tidy_df(dfc) %>% as_tibble()
head(df, 20)
```

```{r}
dfm <- tab_measures(df, ticks_per_beat) %>%
  # create a variable `track` with the track name (in order to have it in the plot below)
  mutate(track = ifelse(purrr::map_chr(name, typeof) != "character", 
                        list(NA_character_), 
                        name)) %>%
  unnest(cols = track) %>% 
  fill(track)
```

```{r}
dfm %>% 
    miditapyr$split_df()  %->% c(df_meta, df_notes)
```

```{r df_meta}
df_meta %>% as_tibble()
```


```{r df_notes}
df_notes %>% as_tibble()
```
```{r child='man/rmdhunks/piano_roll_note_date.Rmd'}
```


```{r child='man/rmdhunks/midi_df_to_file.Rmd'}
```

## Related R packages

* The [noon package](https://github.com/ColinFay/noon) wraps node.js libraries and can be used to read live midi input port data. I wrote a small [blog post](https://urssblogg.netlify.app/post/2020-10-24-live-recording-of-a-midi-controller-via-mido-inport/) how reading a midi port can also be done in R with [mido](https://mido.readthedocs.io/en/latest/ports.html). Interestingly, the node.js libraries and mido rely on a the same C++ library [RtMidi](http://www.music.mcgill.ca/~gary/rtmidi/index.html). 
* The [tuneR](https://cran.r-project.org/package=tuneR) package can also read in midi data. See the [vignette](https://urswilke.github.io/pyramidi/articles/tuner.html), for an example how you can transform the tuner format into the pyramidi format (or run `vignette("tuner", package = "pyramidi")` to load the vignette on your machine). 

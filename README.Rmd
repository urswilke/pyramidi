---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# pyramidi

<!-- badges: start -->
<!-- badges: end -->

**Work in progress!**


The goal of pyramidi is to read in dataframes generated by the python package
[miditapyr](https://pypi.org/project/miditapyr/). These dataframes contain midi data. Then the midi information (one
line per event) can be translated into a wide format (one line per note). This 
facilitates plotting piano roll plots. These dataframes can then be written back
to midi files (again using miditapyr).

## Installation

You can install pyramidi from [github](https://github.com/urswilke/pyramidi) with:

``` r
## install remotes package if it's not already
if (!requireNamespace("remotes", quietly = TRUE)) {
  install.packages("remotes")
}

## install dev version of rtweettree from github
remotes::install_github("UrsWilke/pyramidi")
```

The python package [miditapyr](https://pypi.org/project/miditapyr/) also needs to be installed via 

```sh
pip install miditapyr
```

in your virtual environment.

## Basic usage

### Load libraries

```{r load_libs, message=FALSE}
library(pyramidi)
library(tidyverse)
library(zeallot)
mt <- reticulate::import("miditapyr")
mido <- reticulate::import("mido")
```

### Extract midi file information into dataframe

```{r midi_df, message=FALSE}
midi_file_str <- system.file("extdata", "test_midi_file.mid", package = "pyramidi")

midifile <- mido$MidiFile(midi_file_str)
ticks_per_beat <- midifile$ticks_per_beat

dfc = mt$midi_to_df(midifile)
head(dfc, 20)
```


```{r ticksperbeat}
ticks_per_beat
```


```{r}
df = mt$tidy_df(dfc)
head(df, 20)
```

```{r}
dfm <- tab_measures(df, ticks_per_beat)
```

```{r}
dfm %>% 
    mt$split_df()  %->% c(df_meta, df_notes)
```

```{r df_meta}
df_meta
```


```{r df_notes}
df_notes %>% as_tibble()
```

### Pivot note dataframe to wide

```{r df_notes_wide}
df_not_notes <- 
  df_notes %>% 
  dplyr::filter(!stringr::str_detect(.data$type, "^note_o[nf]f?$")) 

df_notes_wide <-
  df_notes %>% 
  dplyr::filter(stringr::str_detect(.data$type, "^note_o[nf]f?$")) %>%
  # tab_measures(df_meta, df_notes, ticks_per_beat) %>%
  widen_events() %>%
  left_join(pyramidi::midi_defs)
df_notes_wide
```


### Plot the midi file information in a piano roll plot

```{r midi_piano_roll}
p1 <- df_notes_wide %>%
  ggplot() +
  geom_segment(
    aes(
      x = m_note_on,
      y = note_name,
      xend = m_note_off,
      yend = note_name,
      color = velocity_note_on
    )
  ) +
  # each midi track is printed into its own facet:
  facet_wrap( ~ i_track,
              ncol = 1,
              scales = "free_y")
p1

```



### Pivot note data frame back to long format

```{r pivot_long}
df_notes_out <-
  df_notes_wide %>%
  select(c("i_track", 
           # "name", 
           "channel", "note", "i_note"), matches("_note_o[nf]f?$")) %>%
  pivot_longer(matches("_note_o[nf]f?$"),
               names_to = c(".value", "type"),
               names_pattern = "(.+?)_(.*)") %>% 
  mutate(meta = FALSE) 


df_notes_out <-
  df_notes_out %>%
  full_join(df_meta) %>% 
  full_join(df_not_notes) %>%
  arrange(i_track, ticks) %>% 
  group_by(i_track) %>%
  mutate(time = ticks - lag(ticks) %>% {.[1] = 0; .}) %>%
  ungroup()

df_notes_out
```

### Write midi dataframe back to a midi file


```{r dfc2}
dfc2 <- 
  df_notes_out %>% 
  select(names(df)) %>% 
  # mutate_if(is_numeric, as.integer) %>% 
  mutate_if(is.numeric, ~ifelse(is.na(.), NaN, .)) %>%
  mt$compact_df()
```


```{r write_midi, eval=FALSE}
dfc2
dfc2 %>%
  mt$df_to_midi(ticks_per_beat,
                "test.mid")
```


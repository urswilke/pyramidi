---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# pyramidi

<!-- badges: start -->
[![Travis build status](https://travis-ci.com/urswilke/pyramidi.svg?branch=master)](https://travis-ci.com/urswilke/pyramidi)
[![Codecov test coverage](https://codecov.io/gh/urswilke/pyramidi/branch/master/graph/badge.svg)](https://codecov.io/gh/urswilke/pyramidi?branch=master)
<!-- badges: end -->

**Work in progress!**


The goal of pyramidi is to read in dataframes generated by the python package
[miditapyr](https://pypi.org/project/miditapyr/). These dataframes contain midi data. Then the midi information (one
line per event) can be translated into a wide format (one line per note). This 
facilitates plotting piano roll plots. These dataframes can then be written back
to midi files (again using miditapyr).

## Installation

You can install pyramidi from [github](https://github.com/urswilke/pyramidi) with:

``` r
## install remotes package if it's not already
if (!requireNamespace("remotes", quietly = TRUE)) {
  install.packages("remotes")
}

## install dev version of rtweettree from github
remotes::install_github("UrsWilke/pyramidi")
```

The python package [miditapyr](https://pypi.org/project/miditapyr/) also needs to be installed via 

```sh
pip install miditapyr
```

in your virtual environment.

## Basic usage

### Load libraries

```{r load_libs, message=FALSE}
library(pyramidi)
library(tidyverse)
library(zeallot)
mt <- reticulate::import("miditapyr")
mido <- reticulate::import("mido")
```

### Extract midi file information into dataframe

```{r midi_df, message=FALSE}
midi_file_str <- system.file("extdata", "test_midi_file.mid", package = "pyramidi")

midifile <- mido$MidiFile(midi_file_str)
ticks_per_beat <- midifile$ticks_per_beat

dfc = mt$midi_to_df(midifile)
head(dfc, 20)
```


```{r ticksperbeat}
ticks_per_beat
```


```{r}
df <- mt$tidy_df(dfc) %>% as_tibble()
head(df, 20)
```

```{r}
dfm <- tab_measures(df, ticks_per_beat) %>%
  # create a variable `track` with the track name (in order to have it in the plot below)
  mutate(track = ifelse(purrr::map_chr(name, typeof) != "character", 
                        list(NA_character_), 
                        name)) %>%
  unnest(cols = track) %>% 
  fill(track)
```

```{r}
dfm %>% 
    mt$split_df()  %->% c(df_meta, df_notes)
```

```{r df_meta}
df_meta %>% as_tibble()
```


```{r df_notes}
df_notes %>% as_tibble()
```
```{r child='man/rmdhunks/piano_roll_note_date.Rmd'}
```


```{r child='man/rmdhunks/midi_df_to_file.Rmd'}
```

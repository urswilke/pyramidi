---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# pyramidi

<!-- badges: start -->
<!-- badges: end -->

The goal of pyramidi is to read in dataframes generated by the python package
miditapyr. These dataframes contain midi data. Then the midi information (one
line per event) can be translated into a wide format (one line per note). This 
facilitates plotting piano roll plots. These dataframes can then be written back
to midi files (again using miditapyr).

## Installation

You can install the released version of pyramidi from [github](https://github.com/urswilke/pyramidi) with:

``` r
## install remotes package if it's not already
if (!requireNamespace("remotes", quietly = TRUE)) {
  install.packages("remotes")
}

## install dev version of rtweettree from github
remotes::install_github("UrsWilke/pyramidi")
```

## Basic usage

### Load libraries

```{r load_libs, message=FALSE}
library(pyramidi)
library(tidyverse)
library(zeallot)
mt <- reticulate::import("miditapyr")
mido <- reticulate::import("mido")
```

### Extract midi file information into dataframes

```{r midi_df, message=FALSE}
mid_file <- system.file("extdata", "test_midi_file.mid", package = "pyramidi")
mido$MidiFile(mid_file) %>%
  mt$mido_midi_df()  %->% c(df_meta, df_notes, ticks_per_beat)
```


```{r df_meta}
df_meta
```


```{r df_notes}
df_notes %>% as_tibble()
```


```{r ticksperbeat}
ticks_per_beat
```

### Pivot note dataframe to wide 

```{r df_notes_wide}

df_notes_wide <-  
  tab_measures(df_meta, df_notes, ticks_per_beat) %>%
  widen_events() %>%
  left_join(pyramidi::midi_defs)
df_notes_wide
```

### Plot the midi file information in a piano roll plot

```{r midi_piano roll}
p1 <- df_notes_wide %>%
  ggplot() +
  geom_segment(
    aes(
      x = m_note_on,
      y = note_name,
      xend = m_note_off,
      yend = note_name,
      color = velocity_note_on
    )
  ) +
  # each midi track is printed into its own facet:
  facet_wrap( ~ i_track,
              ncol = 1,
              scales = "free_y")
p1

```



### Pivot note data frame back to long format

```{r pivot_long}
df_notes_out <- 
  df_notes_wide %>% 
  select(c("i_track", "name", "channel", "note", "i_note"), matches("_note_o[nf]f?$")) %>% 
  pivot_longer(matches("_note_o[nf]f?$"),
               names_to = c(".value", "type"),
               names_pattern = "(.+?)_(.*)") %>% 
  arrange(i_track, t)

df_notes_out <- 
  df_notes_out %>% 
  group_by(i_track) %>% 
  mutate(time = ticks - lag(ticks) %>% {.[1] = 0; .}) %>% 
  ungroup()

df_notes_out
```

### Write midi dataframe back to a midi file


```{r write_midi, eval=FALSE}
mt$df_2_midi(df_meta %>% mutate(time = as.integer(time)), 
             df_notes_out, 
             ticks_per_beat, 
             "test.mid")
```


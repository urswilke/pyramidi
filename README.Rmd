---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# pyramidi <a href='https://github.com/urswilke/pyramidi/'><img src='man/figures/hex-pyramidi_compact.png' align="right" height="139" /></a>

<!-- badges: start -->
[![Travis build status](https://travis-ci.org/urswilke/pyramidi.svg?branch=master)](https://travis-ci.org/github/urswilke/pyramidi)
[![Codecov test coverage](https://codecov.io/gh/urswilke/pyramidi/branch/master/graph/badge.svg)](https://codecov.io/gh/urswilke/pyramidi?branch=master)
[![R-CMD-check](https://github.com/urswilke/pyramidi/workflows/R-CMD-check/badge.svg)](https://github.com/urswilke/pyramidi/actions)
<!-- badges: end -->

**Work in progress!**

♪ ♫ ♩ ♬ ♪ ♫ ♩ ♬ ♪ ♫ ♩ ♬ ♪ ♫ ♩ ♬ ♪ ♫ ♩ ♬ ♪ ♫ ♩ ♬ ♪ ♫ ♩ ♬ ♪ ♫ ♩ ♬ ♪ ♫ ♩ ♬ 

The goal of pyramidi is to read in dataframes generated by the python package
[miditapyr](https://pypi.org/project/miditapyr/). These dataframes contain midi data. Then the midi information (one
line per event) can be translated into a wide format (one line per note). This 
facilitates plotting piano roll plots. These dataframes can then be written back
to midi files (again using miditapyr).

## Installation

You can install pyramidi from [github](https://github.com/urswilke/pyramidi) with:

``` r
## install remotes package if it's not already
if (!requireNamespace("remotes", quietly = TRUE)) {
  install.packages("remotes")
}

## install dev version of rtweettree from github
remotes::install_github("UrsWilke/pyramidi")
```

The python package [miditapyr](https://pypi.org/project/miditapyr/) also needs to be installed via 

```sh
pip install miditapyr
```

in your python environment used by reticulate.

## Basic usage

### Load libraries
```{r, reticulate_local, echo=FALSE}
reticulate::use_python("/home/chief/anaconda3/bin/python")

```

First load some libraries:

```{r load_libs, message=FALSE}
library(pyramidi)
library(tidyverse)
library(zeallot)
```

### Extract midi file information into dataframe


```{r midi_df, message=FALSE}
midi_file_str <- system.file("extdata", "test_midi_file.mid", package = "pyramidi")

midifile <- mido$MidiFile(midi_file_str)
ticks_per_beat <- midifile$ticks_per_beat
```

Now we can load the information of the `midifile` into a dataframe:

```{r midi_df2, message=FALSE}
dfc = miditapyr$midi_to_df(midifile)
head(dfc, 20)
```

This dataframe contains the columns of the track index `i_track`, `meta` (whether the midi event is a note event), and `msg` containing named lists of further midi event information.

The `MidiFile()` function of `mido` also yields the [`ticks_per_beat`](https://mido.readthedocs.io/en/latest/midi_files.html#tempo-and-beat-resolution) of the file:

```{r ticksperbeat}
ticks_per_beat
```

The `miditapyr$tidy_df()` function transforms the `msg` column of the dataframe to a wide format, where every new column name corresponds to the names in the lists in `msg`  (like `tidyr::unnest_wider()`):

```{r}
df <- miditapyr$tidy_df(dfc) %>% as_tibble()
head(df, 20)
```

### Translate midi time information

In the midi format, time is treated as relative increments between events (measured in ticks). 
In order to derive the total time passed, you can use the function `tab_measures()`:


```{r}
dfm <- tab_measures(df, ticks_per_beat) %>%
  # create a variable `track` with the track name (in order to have it in the plot below)
  mutate(track = ifelse(purrr::map_chr(name, typeof) != "character", 
                        list(NA_character_), 
                        name)) %>%
  unnest(cols = track) %>% 
  fill(track)
```

This function adds further columns:

* `ticks`: specifying the total ticks passed,
* `t`: specifying the total time in seconds passed,
* `m`: specifying the total [measures](https://en.wikipedia.org/wiki/Bar_(music)) passed,
* `b`: specifying the total [beats](https://en.wikipedia.org/wiki/Beat_(music)) passed,
* `i_note`: unique ascending index for every track and midi note in the midi file.

### Further processing of the midi events

You can split the dataframe in two by whether the events are [meta](https://mido.readthedocs.io/en/latest/meta_message_types.html) or not:

```{r}
dfm %>% 
    miditapyr$split_df() %->% c(df_meta, df_notes)
```

```{r df_meta}
df_meta %>% as_tibble()
```


```{r df_notes}
df_notes %>% as_tibble()
```



```{r child='man/rmdhunks/piano_roll_note_date.Rmd'}
```

### Manipulation of the midi data

The wide format also allows to easily manipulate the midi data. For instance, let's put the volume (called `velocity` in midi) of the first beat in every bar to the maximum (127), and to half of its original value otherwise:

```{r}
df_notes_wide <- df_notes_wide %>% 
  mutate(
    velocity_note_on = ifelse(
      # As it's a 4/4 beat, the first beat of each bar is a multiple of 4:
      b_note_on %% 4 == 0, 
      127, 
      velocity_note_on / 2
    )
  )
```


```{r child='man/rmdhunks/midi_df_to_file.Rmd'}
```

## Related R packages

* The [noon package](https://github.com/ColinFay/noon) wraps node.js libraries and can be used to read live midi input port data. I wrote a small [blog post](https://urssblogg.netlify.app/post/2020-10-24-live-recording-of-a-midi-controller-via-mido-inport/) how reading a midi port can also be done in R with [mido](https://mido.readthedocs.io/en/latest/ports.html). Interestingly, the node.js libraries and mido rely on a the same C++ library [RtMidi](http://www.music.mcgill.ca/~gary/rtmidi/index.html). 
* The [tuneR](https://cran.r-project.org/package=tuneR) package can also read in midi data. See the [vignette](https://urswilke.github.io/pyramidi/articles/tuner.html), for an example how you can transform the tuner format into the pyramidi format (or run `vignette("tuner", package = "pyramidi")` to load the vignette on your machine). 

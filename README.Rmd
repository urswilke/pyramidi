---
output: github_document
bibliography: pkg-refs.bib
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# pyramidi <a href='https://github.com/urswilke/pyramidi/'><img src='man/figures/hex_logo_pyramidi.png' align="right" height="139" /></a>

<!-- badges: start -->
[![Travis build status](https://travis-ci.org/urswilke/pyramidi.svg?branch=master)](https://travis-ci.org/github/urswilke/pyramidi)
[![Codecov test coverage](https://codecov.io/gh/urswilke/pyramidi/branch/master/graph/badge.svg)](https://codecov.io/gh/urswilke/pyramidi?branch=master)
[![R-CMD-check](https://github.com/urswilke/pyramidi/workflows/R-CMD-check/badge.svg)](https://github.com/urswilke/pyramidi/actions)
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)
<!-- badges: end -->

**Work in progress!**

â™ª â™« â™© â™¬ â™ª â™« â™© â™¬ â™ª â™« â™© â™¬ â™ª â™« â™© â™¬ â™ª â™« â™© â™¬ â™ª â™« â™© â™¬ â™ª â™« â™© â™¬ â™ª â™« â™© â™¬ â™ª â™« â™© â™¬ 

The goal of pyramidi is to read in dataframes generated by the python package
[miditapyr](https://pypi.org/project/miditapyr/). These dataframes contain midi data. Then the midi information (one
line per event) can be translated into a wide format (one line per note). This 
facilitates plotting piano roll plots. These dataframes can then be written back
to midi files (again using miditapyr).

Thus you can manipulate these dataframes at all steps and write midi files from R. You need to make sure yourself that the midi files you write can be understood by your softsynth; but [mido](https://github.com/mido/mido) (used by miditapyr) already catches some of the possible inconsistencies.

*I started to write these packages quite some time ago. They are sometimes not very well designed. For now `miditapyr` only contains one module with functions. And the functionality of `pyramidi` is quite limited and necessitates a lot of manual intermediate steps. But the loose structure allows you to generate & manipulate midi data on many different levels.* 

## Installation

You can install pyramidi from [github](https://github.com/urswilke/pyramidi) with:

``` r
## install remotes package if it's not already
if (!requireNamespace("remotes", quietly = TRUE)) {
  install.packages("remotes")
}

## install dev version of rtweettree from github
remotes::install_github("UrsWilke/pyramidi")
```

The python package [miditapyr](https://pypi.org/project/miditapyr/) also needs to be installed via 

```sh
pip install miditapyr
```

in your python environment used by [reticulate](https://github.com/rstudio/reticulate).

But if everything works as it should ðŸ¤žðŸ˜…, miditapyr is automatically installed
if you install pyramidi, as soon as you access the module for the first time. (I'm not sure if that works on windows too. Perhaps there you have to configure your reticulate environment manually.)

Otherwise, you can also install it
in your reticulate python environment
with the included helper function:

```{r, eval=FALSE}
pyramidi::install_miditapyr()
```


## Usage 

### Generate R midi_frames object

We can create an R midi frames object by passing the file file path to the  
constructor. 

```{r, message=FALSE}
library(pyramidi)
library(dplyr)
midi_file_string <- system.file("extdata", "test_midi_file.mid", package = "pyramidi")
mfr <- r_midi_frames(midi_file_string)
```



The object contains the midi data in various dataframe formats and an interface
to the miditapyr
[miditapyr.MidiFrames](https://miditapyr.readthedocs.io/en/latest/notebooks/midi_frame_usage.html)
object `mfr$mf`.  You can write the midi file resulting of the MidiFrame object to disk:

```{r, eval=FALSE}
mfr$mf$write_file("/path/to/your/midifile.mid")
```


## Modifying midi data

In the R midi frames object, we can modify `mfr$df_notes_wide`, the notes in notewise wide format
(`note_on` & `note_off` events in the same line). Thus we don't need to worry which 
midi events belong together

Let's look at a small example. We'll define a function to replace every 
note with a random midi note between 60 & 71::

```{r}
mod <- function(dfn, seed) {
  n_notes <- sum(!is.na(dfn$note))
  dfn %>% mutate(note = ifelse(
    !is.na(note),
    sample(60:71, n_notes, TRUE),
    note
  ))
}
```


When we call `mod_notes()`, the midi data in `mfr` is updated:

```{r, message=FALSE}
mfr <- mod_notes(mfr, mod)
```


## Writing modified midi files

Thus, we can now save the modifications to a midi file:

```{r}
mfr$mf$write_file("mod_test_midi_file.mid")
```

## Synthesizing and playing audio

See the `vignette("midi_framer", package = "pyramidi")` to see how you can
synthesize the midi data to wav, convert to mp3 if you want, and then 
embed a player in your rmarkdown html document with
```{r, eval=FALSE}
play_midi_frame(mfr)
```


```{r echo=FALSE}
htmltools::tags$audio(
    controls = "",
    htmltools::tags$source(
      src = "https://urswilke.github.io/pyramidi/articles/mod_test_midi_file.mp3",
      type = "audio/mp3"
    )
  )
```





## Related R packages

* The [noon package](https://github.com/ColinFay/noon) wraps node.js libraries and can be used to read live midi input port data. I wrote a small [blog post](https://urssblogg.netlify.app/post/2020-10-24-live-recording-of-a-midi-controller-via-mido-inport/) how reading a midi port can also be done in R with [mido](https://mido.readthedocs.io/en/latest/ports.html). Interestingly, the node.js libraries and mido rely on a the same C++ library [RtMidi](http://www.music.mcgill.ca/~gary/rtmidi/index.html). 
* The [tuneR](https://cran.r-project.org/package=tuneR) package can also read in midi data. See the [vignette](https://urswilke.github.io/pyramidi/articles/tuner.html), for an example how you can transform the tuner format into the pyramidi format (or run `vignette("tuner", package = "pyramidi")` to load the vignette on your machine). 


<!-- 
The following as well as the bibtex file "pkg-refs.bib" were automatically
created with the commands:
library(grateful)
pkgs <- scan_packages()
# don't know why including "R" gives an error ??
pkgs <- pkgs[!pkgs %in% c("R", "pyramidi")] %>% c("rayrender", "magick")
cites <- get_citations(pkgs)
rmd <- create_rmd(cites)

-> then copy the list in the created refs.Rmd below

-->

## R packages used

This package stands on the shoulders of giants. A big thank you to the authors of the following libraries!

- base [@base]
- pkgdown [@pkgdown]
- usethis [@usethis]
- dplyr [@dplyr]
- forcats [@forcats]
- tibble [@tibble]
- tidyr [@tidyr]
- pichor [@pichor]
- rvest [@rvest]
- tidyverse [@tidyverse]
- reticulate [@reticulate]
- purrr [@purrr]
- stringr [@stringr]
- ggplot2 [@ggplot2]
- zeallot [@zeallot]
- magrittr [@magrittr]
- rlang [@rlang]
- knitr [@knitr]
- rmarkdown [@rmarkdown]
- testthat [@testthat]
- covr [@covr]
- rayrender [@rayrender]
- magick [@magick]

## References

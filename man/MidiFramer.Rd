% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/r6midi.R
\name{MidiFramer}
\alias{MidiFramer}
\title{MidiFramer class}
\description{
The class \code{MidiFramer} can be used to read midi files to
dataframes in order to facilitate to manipulate the data from R. You can also
create midi data from R without reading it from a file.
The data is transformed to various formats.
One of the \code{MidiFramer} fields is a
\href{https://miditapyr.readthedocs.io/en/latest/miditapyr.html#miditapyr.midi_frame.MidiFrames}{\code{MidiFrames}}
object of the python miditapyr package. Its method
\href{https://miditapyr.readthedocs.io/en/latest/miditapyr.html#miditapyr.midi_frame.MidiFrames.write_file}{write_file()}
can be used to write the data back to a midi file.
}
\details{
\itemize{
\item{See the \code{vignette("pyramidi")} for a brief usage introduction how to manipulate midi data.}
\item{The \code{vignette("compose")} shows a more extended example how to generate midi files from scratch.}
\item{\code{vignette("package_workflow")} shows in detail the structure of the \code{MidiFramer} class.}
\item{\code{vignette("functions_usage")} illustrates the low-level functions of the pyramidi package.
that \code{MidiFramer} objects use under the hood.}
}
}
\examples{
\dontrun{
## Create a MidiFramer object from a midi file:
midi_file_string <- system.file("extdata", "test_midi_file.mid", package = "pyramidi")
MidiFramer$new(midi_file_string)

## ------------------------------------------------
## Create empty MidiFramer object to illustrate
## the use of the `ticks_per_beat` active binding:
## ------------------------------------------------

mfr <- MidiFramer$new()
# Print default value of empty MidiFile object:
mfr$mf$midi_file$ticks_per_beat
# Modify it with the active binding ticks_per_beat:
mfr$ticks_per_beat <- 960L
# Print it again:
mfr$mf$midi_file$ticks_per_beat
}

## ------------------------------------------------
## Method `MidiFramer$update_notes_wide`
## ------------------------------------------------

\dontrun{
midi_file_string <- system.file("extdata", "test_midi_file.mid", package = "pyramidi")
mfr <- MidiFramer$new(midi_file_string)
# Function to replace every note with a random midi note between 60 & 71:
mod <- function(dfn) {
  n_notes <- sum(!is.na(dfn$note))
  dfn \%>\% dplyr::mutate(note = ifelse(
    !is.na(note),
    sample(60:71, n_notes, TRUE),
    note
  ))
}
set.seed(123)
mfr$update_notes_wide(mod)
mfr$play()
# You can pass functions to the $update_notes_wide() method (as above), but
# you can also modify the dataframe directly and pass it. Therefore, the
# following results in the same:
set.seed(123)
df_mod <- mod(mfr$df_notes_wide)
mfr$update_notes_wide(df_mod)
mfr$play()
}

## ------------------------------------------------
## Method `MidiFramer$populate_r_fields`
## ------------------------------------------------

\dontrun{
midi_file_string <- system.file("extdata", "test_midi_file.mid", package = "pyramidi")
mfr <- MidiFramer$new(midi_file_string)
mfr$params$columns_to_add <- c("m", "b", "t", "time")
mfr$populate_r_fields()
}

## ------------------------------------------------
## Method `MidiFramer$play`
## ------------------------------------------------

\dontrun{
midi_file_string <- system.file("extdata", "test_midi_file.mid", package = "pyramidi")
mfr <- MidiFramer$new(midi_file_string)
mfr$play()
}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{midi_file_string}}{Path to the midi file.}

\item{\code{mf}}{\href{https://miditapyr.readthedocs.io/en/latest/miditapyr.html#miditapyr.midi_frame.MidiFrames}{\code{miditapyr$MidiFrames}} object.}

\item{\code{dfm}}{result of \code{tab_measures()}.}

\item{\code{df_notes_long}}{Result of \code{pivot_long_notes()}.}

\item{\code{df_meta, df_not_notes, df_notes_wide}}{Results of \code{split_midi_frame()}.}

\item{\code{midi_frame_mod}}{Result of \code{merge_midi_frames()}.}

\item{\code{params}}{Parameters used in internal functions; Named list; params$columns_to_add is passed to \code{tab_measures(columns_to_add)}.}
}
\if{html}{\out{</div>}}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{df_meta, df_not_notes, df_notes_wide}}{Results of \code{split_midi_frame()}.}

\item{\code{ticks_per_beat}}{Set ticks per beat of \code{MidiFrames()$mf$midi_file}.
The value of \code{ticks_per_beat} passed should be integer.
When a value is passed, the field \code{mf$midi_file field$ticks_per_beat} is modified.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{MidiFramer$new()}}
\item \href{#method-update_notes_wide}{\code{MidiFramer$update_notes_wide()}}
\item \href{#method-populate_r_fields}{\code{MidiFramer$populate_r_fields()}}
\item \href{#method-play}{\code{MidiFramer$play()}}
\item \href{#method-clone}{\code{MidiFramer$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Initialize a MidiFramer object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MidiFramer$new(midi_file_string = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{midi_file_string}}{Path to the midi file; if NULL (the default), an empty \code{MidiFramer} object is created.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-update_notes_wide"></a>}}
\if{latex}{\out{\hypertarget{method-update_notes_wide}{}}}
\subsection{Method \code{update_notes_wide()}}{
Update a MidiFramer object with modified notes
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MidiFramer$update_notes_wide(mod)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{mod}}{Dataframe or function returning a dataframe of the format of \code{df_notes_wide}.}
}
\if{html}{\out{</div>}}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
midi_file_string <- system.file("extdata", "test_midi_file.mid", package = "pyramidi")
mfr <- MidiFramer$new(midi_file_string)
# Function to replace every note with a random midi note between 60 & 71:
mod <- function(dfn) {
  n_notes <- sum(!is.na(dfn$note))
  dfn \%>\% dplyr::mutate(note = ifelse(
    !is.na(note),
    sample(60:71, n_notes, TRUE),
    note
  ))
}
set.seed(123)
mfr$update_notes_wide(mod)
mfr$play()
# You can pass functions to the $update_notes_wide() method (as above), but
# you can also modify the dataframe directly and pass it. Therefore, the
# following results in the same:
set.seed(123)
df_mod <- mod(mfr$df_notes_wide)
mfr$update_notes_wide(df_mod)
mfr$play()
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-populate_r_fields"></a>}}
\if{latex}{\out{\hypertarget{method-populate_r_fields}{}}}
\subsection{Method \code{populate_r_fields()}}{
Populate the fields of a MidiFramer object

This can also be used to recalculate all the object's attributes,
when a value in params is changed (see examples).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MidiFramer$populate_r_fields()}\if{html}{\out{</div>}}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
midi_file_string <- system.file("extdata", "test_midi_file.mid", package = "pyramidi")
mfr <- MidiFramer$new(midi_file_string)
mfr$params$columns_to_add <- c("m", "b", "t", "time")
mfr$populate_r_fields()
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-play"></a>}}
\if{latex}{\out{\hypertarget{method-play}{}}}
\subsection{Method \code{play()}}{
Play midi from MidiFramer object.
Transform the midi file to fileext format and provide a play button for html
documents.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MidiFramer$play(
  audiofile = tempfile("mf_out_", fileext = ".wav"),
  overwrite = FALSE,
  soundfont = NULL,
  verbose = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{audiofile}}{Path to the audiofile to be synthesized. If audiofile of type mp3, it will
first be synthesized to wav, and then converted to mp3 with ffmpeg.}

\item{\code{overwrite}}{logical; defaults to FALSE;
if file exists and overwrite = FALSE, the existing files will be used and nothing
is synthesized/converted to audio files.}

\item{\code{soundfont}}{path to sf2 sound font (character string); if NULL (the default)
the default soundfont is used.}

\item{\code{verbose}}{logical whether to print fluidsynth (and ffmpeg in case of mp3 audiofile type) command line output; defaults to FALSE}
}
\if{html}{\out{</div>}}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
midi_file_string <- system.file("extdata", "test_midi_file.mid", package = "pyramidi")
mfr <- MidiFramer$new(midi_file_string)
mfr$play()
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MidiFramer$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}

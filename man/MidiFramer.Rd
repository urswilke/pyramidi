% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/r6midi.R
\name{MidiFramer}
\alias{MidiFramer}
\title{Construct a midi frame R6 object}
\value{
MidiFramer R6 object
}
\description{
Construct a midi frame R6 object

Construct a midi frame R6 object
}
\details{
Constructor of an object of class "MidiFramer".
}
\examples{
\dontrun{
midi_file_string <- system.file("extdata", "test_midi_file.mid", package = "pyramidi")
MidiFramer$new(midi_file_string)
}

## ------------------------------------------------
## Method `MidiFramer$update_notes_wide`
## ------------------------------------------------

\dontrun{
midi_file_string <- system.file("extdata", "test_midi_file.mid", package = "pyramidi")
mfr <- MidiFramer$new(midi_file_string)
# Function to replace every note with a random midi note between 60 & 71:
mod <- function(dfn) {
  n_notes <- sum(!is.na(dfn$note))
  dfn \%>\% dplyr::mutate(note = ifelse(
    !is.na(note),
    sample(60:71, n_notes, TRUE),
    note
  ))
}
set.seed(123)
mfr$update_notes_wide(mod)
mfr$play()
# You can pass functions to the $update_notes_wide() method (as above), but
# you can also modify the dataframe directly and pass it. Therefore, the
# following results in the same:
set.seed(123)
df_mod <- mod(mfr$df_notes_wide)
mfr$update_notes_wide(df_mod)
mfr$play()
}

## ------------------------------------------------
## Method `MidiFramer$play`
## ------------------------------------------------

\dontrun{
midi_file_string <- system.file("extdata", "test_midi_file.mid", package = "pyramidi")
mfr <- MidiFramer$new(midi_file_string)
mfr$play()
}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{midi_file_string}}{Path to the midi file}

\item{\code{mf}}{miditapyr$MidiFrames object,}

\item{\code{dfm}}{result of \code{tab_measures()}}

\item{\code{df_notes_long}}{result of \code{pivot_long_notes()}}

\item{\code{df_meta, df_not_notes, df_notes_wide}}{results of \code{triage_measured_unnested()}}

\item{\code{df_long_mod}}{result of \code{merge_long_events()}}
}
\if{html}{\out{</div>}}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{df_meta, df_not_notes, df_notes_wide}}{results of \code{triage_measured_unnested()}}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{MidiFramer$new()}}
\item \href{#method-update_notes_wide}{\code{MidiFramer$update_notes_wide()}}
\item \href{#method-play}{\code{MidiFramer$play()}}
\item \href{#method-clone}{\code{MidiFramer$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Initialize a MidiFramer object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MidiFramer$new(midi_file_string)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{midi_file_string}}{Path to the midi file}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-update_notes_wide"></a>}}
\if{latex}{\out{\hypertarget{method-update_notes_wide}{}}}
\subsection{Method \code{update_notes_wide()}}{
Update a MidiFramer object with modified notes
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MidiFramer$update_notes_wide(mod)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{mod}}{Dataframe or function returning a dataframe of the format of \code{df_notes_wide}.}
}
\if{html}{\out{</div>}}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
midi_file_string <- system.file("extdata", "test_midi_file.mid", package = "pyramidi")
mfr <- MidiFramer$new(midi_file_string)
# Function to replace every note with a random midi note between 60 & 71:
mod <- function(dfn) {
  n_notes <- sum(!is.na(dfn$note))
  dfn \%>\% dplyr::mutate(note = ifelse(
    !is.na(note),
    sample(60:71, n_notes, TRUE),
    note
  ))
}
set.seed(123)
mfr$update_notes_wide(mod)
mfr$play()
# You can pass functions to the $update_notes_wide() method (as above), but
# you can also modify the dataframe directly and pass it. Therefore, the
# following results in the same:
set.seed(123)
df_mod <- mod(mfr$df_notes_wide)
mfr$update_notes_wide(df_mod)
mfr$play()
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-play"></a>}}
\if{latex}{\out{\hypertarget{method-play}{}}}
\subsection{Method \code{play()}}{
Play midi from MidiFramer object
Transform the midi file to fileext format and provide a play button for html
documents.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MidiFramer$play(
  audiofile = tempfile("mf_out_", fileext = ".wav"),
  overwrite = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{audiofile}}{Path to the audiofile to be synthesized}

\item{\code{overwrite}}{logical; defaults to FALSE;
if file exists and overwrite = FALSE, the existing files will be used and nothing
is synthesized/converted to audio files.}
}
\if{html}{\out{</div>}}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
midi_file_string <- system.file("extdata", "test_midi_file.mid", package = "pyramidi")
mfr <- MidiFramer$new(midi_file_string)
mfr$play()
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MidiFramer$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}

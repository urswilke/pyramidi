---
title: "Midi manipulation with pyramidi"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Midi manipulation with pyramidi}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r, include=FALSE, message=FALSE}
pyramidi::install_miditapyr(envname = "r-reticulate")
```

## Load libraries

```{r setup, message=FALSE}
library(pyramidi)
library(dplyr)
library(purrr)
library(htmltools)
library(tibble)
# This is a small helper package, that allows to synthesize & play midi files:
library(raudiomate) # see https://github.com/urswilke/raudiomate
```

## Generate R midi frames object

We can create an R6 object of class `"MidiFramer"` by passing the midi file path to the  
constructor function `MidiFramer$new()`: 

```{r, message=FALSE}
midi_file_string <- system.file("extdata", "test_midi_file.mid", package = "pyramidi")
mfr <- MidiFramer$new(midi_file_string)
class(mfr)
```

It is an R6 object that contains the following fields:

```{r}
enframe(as.list(mfr))
```

`mf` is a `miditapyr.MidiFrames()` object. After its first element `mfr$mf$midi_file`, a [mido midi file object](https://mido.readthedocs.io/en/latest/midi_files.html) with the raw data, there are the 3 dataframes:

```{r}
list(
    mfr$mf$midi_frame_raw,
    mfr$mf$midi_frame_unnested$df,
    mfr$mf$midi_frame_nested$df
  ) %>% 
  # for prettier printing:
  map(as_tibble)
```

And you can write the midi file resulting of the `MidiFrames` object to disk:

```{r, eval=FALSE}
mfr$mf$write_file("/path/to/your/midifile.mid")
```


## Modifying midi data

In the R midi frames object, we can modify `mfr$df_notes_wide`, the notes in notewise wide format
(`note_on` & `note_off` events in the same line). Thus we don't need to worry which 
midi events belong together

Let's look at a small example. We'll define a function to replace every 
note with a random midi note between 60 & 71::

```{r}
mod <- function(dfn, seed) {
  n_notes <- sum(!is.na(dfn$note))
  dfn %>% mutate(note = ifelse(
    !is.na(note),
    sample(60:71, n_notes, TRUE),
    note
  ))
}
```

We could modify the notes in wide format like this:

```{r}
mod(mfr$df_notes_wide)
```

Then we would have to adapt all the following elements of `mfr` that depend on `mfr$df_notes_wide`.

When we call the method `mfr$update_notes_wide()`, all the depending list elements are also automatically updated.

```{r, message=FALSE}
# Apply the modification to mfr$df_notes_wide and all depending dataframes:
mfr$update_notes_wide(mod)
```

The data has also been changed in `mfr$mf` the miditapyr `MidiFrames` object in mfr:

```{r}
mfr$mf$midi_frame_nested$df %>% head()
```


## Writing modified midi files

Thus we can now directly save the modifications to a midi file:

```{r}
mfr$mf$write_file("mod_test_midi_file.mid")
```


## Playing audio

**You need to install fluidsynth if you want to do that on your computer.**

If you want to produce audio files from the midi files you can synthesize them
with the convenience function `synthesize_midi()`

```{r}
midifile <- "mod_test_midi_file.mid"
mp3file <- "mod_test_midi_file.mp3"
wavfile <- "mod_test_midi_file.wav"
```


```{r, eval=FALSE}
synthesize_midi(midifile, wavfile)
```

You can also listen to your synthesized files by embedding an audio player for the 
`r_midi_frames` object:

```{r, eval=FALSE}
mfr$play(mp3file)
```

```{r echo=FALSE}
htmltools::tags$audio(
    controls = "",
    htmltools::tags$source(
      src = mp3file,
      type = "audio/mp3"
    )
  )
```


To play the audio, this saves the synthesized file under the path specified in `mp3file`.

## Multiple results

You can also embed multiple (in this case 2) audio files in one call using `purrr::map()` functions:

```{r, message=FALSE}
l_mfr <- 1:2 %>%
  set_names(paste0("test", ., ".mp3")) %>% 
  imap(~mfr$update_notes_wide(mod)$play(audiofile = .y))
```



```{r}
tagList(
  imap(
    l_mfr, 
    ~ div(
      h4(paste("audio result", .y)),
      .x,
      # add 2 line breaks to vertically separate a bit:
      br(), 
      br()
    )
  )
)
```

